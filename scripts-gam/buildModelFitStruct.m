function model_fit_struct = buildModelFitStruct( ...
    model_template, model_struct, io_struct)

% function defines a preexisting set of model templates to choose from, and
% allows the user to add one or more custom templates for fitting
%
% INPUTS:
%   model_template (struct)
%   model_struct
%       fit_type
%       stim_struct
%       num_bfs.add/mult
%       num_int_bfs.add/mult
%       bf_symm.add/mult
%       reg_params.stim/add/mult
%           weights
%           biases
%       optim_params
%           max_iter
%           disp
%           deriv_check
%       mult_nonlin
%       noise_dist
%       spiking_nl
%       fit_stim
%       init_loo_w_full
%   io_struct
%       saving
%       overwrite
%       model_dir
%       sub_dir

% redefine variables in struct for easy access
net_io = io_struct;
num_bfs = model_struct.num_bfs;
num_int_bfs = model_struct.num_int_bfs;
reg_params = model_struct.reg_params;
model_struct.stim_struct.num_lags = 1;      % legacy bs for now
model_struct.stim_struct.tent_spacing = 1;  % legacy bs for now
fit_stim = model_struct.fit_stim;

% struct for specification of fitting scheme
net_fit = model_struct.optim_params;
net_fit.noise_dist = model_struct.noise_dist;
net_fit.spiking_nl = model_struct.spiking_nl;
net_fit.fit_type = model_struct.fit_type;
net_fit.init_loo_w_full = model_struct.init_loo_w_full;
    
% placeholder for actual number of cells once data has been loaded
num_cells = -1;

% initializate struct that will contain info for all models
model_fit_struct = struct([]);

%% independent model - just model stim response
if isfield(model_template, 'ind') && model_template.ind

    % struct for input/output parameters
    net_io.filename_ext = 'ind';
    
    % struct for network architecture
    net_arch = struct([]);
    % stim subunit
    temp_arch = struct( ...
        'type', 'add', ...
        'add_targs', [], ...
        'input_targ', 1, ...
        'input_loc', [], ...
        'input_type', 'stim', ...
        'input_lags', model_struct.stim_struct.num_lags, ...
        'input_tent_spacing', model_struct.stim_struct.tent_spacing, ...
        'init', 'stim', ...
        'reg_params_weights', reg_params.stim.weights, ...
        'reg_params_biases', reg_params.stim.biases, ...
        'layers', [num_cells], ...
        'act_funcs', {{'lin'}}, ...
        'fit_layers', [0]);
    net_arch = cat(1, net_arch, temp_arch);
    
    % put it all together
    temp_fit_struct = struct( ...
        'net_io', net_io, ...
        'net_arch', net_arch, ...
        'net_fit', net_fit);
    
    % append to model_fit_struct
    model_fit_struct = cat(1, model_fit_struct, temp_fit_struct);

end


%% add-pop - additive model using population activity
if isfield(model_template, 'add_pop') && model_template.add_pop
            
    % struct for input/output parameters
    net_io.filename_ext = 'add-pop';
                                     
    % struct for network architecture
    net_arch = struct([]);
    if num_int_bfs.add == 0
        layers = [num_bfs.add, num_cells];
        act_funcs = {{'lin', 'lin'}};
    else
        if model_struct.bfs_symm.add == 1
            layers = ...
                [num_int_bfs.add, num_bfs.add, num_int_bfs.add, num_cells];
            act_funcs = {{'relu', 'relu', 'relu', 'lin'}};
        else
            layers = [num_int_bfs.add, num_bfs.add, num_cells];
            act_funcs = {{'relu', 'relu', 'lin'}};
        end
    end
    % stim subunit
    temp_arch = struct( ...
        'type', 'add', ...
        'add_targs', [], ...
        'input_targ', 1, ...
        'input_loc', [], ...
        'input_type', 'stim', ...
        'input_lags', model_struct.stim_struct.num_lags, ...
        'input_tent_spacing', model_struct.stim_struct.tent_spacing, ...
        'init', 'stim', ...
        'reg_params_weights', reg_params.stim.weights, ...
        'reg_params_biases', reg_params.stim.biases, ...
        'layers', [num_cells], ...
        'act_funcs', {{'lin'}}, ...
        'fit_layers', [fit_stim]);
    net_arch = cat(1, net_arch, temp_arch);
    % additive subunit
    temp_arch = struct( ...
        'type', 'add', ...
        'add_targs', [], ...
        'input_targ', 2, ...
        'input_loc', [], ...
        'input_type', 'pop', ...
        'input_lags', 1, ...
        'input_tent_spacing', 1, ...
        'init', 'gauss', ...
        'reg_params_weights', reg_params.add.weights, ...
        'reg_params_biases', reg_params.add.biases, ...
        'layers', layers, ...
        'act_funcs', act_funcs, ...
        'fit_layers', ones(length(layers), 1));
    net_arch = cat(1, net_arch, temp_arch);

    % put it all together
    temp_fit_struct = struct( ...
        'net_io', net_io, ...
        'net_arch', net_arch, ...
        'net_fit', net_fit);

    % append to model_fit_struct
    model_fit_struct = cat(1, model_fit_struct, temp_fit_struct);
    
end

%% add-popavg - additive model using average population activity
if isfield(model_template, 'add_popavg') && model_template.add_popavg
            
    % struct for input/output parameters
    net_io.filename_ext = 'add-popavg';
                                      
    % struct for network architecture
    net_arch = struct([]);
    % stim subunit
    temp_arch = struct( ...
        'type', 'add', ...
        'add_targs', [], ...
        'input_targ', 1, ...
        'input_loc', [], ...
        'input_type', 'stim', ...
        'input_lags', model_struct.stim_struct.num_lags, ...
        'input_tent_spacing', model_struct.stim_struct.tent_spacing, ...
        'init', 'stim', ...
        'reg_params_weights', reg_params.stim.weights, ...
        'reg_params_biases', reg_params.stim.biases, ...
        'layers', [num_cells], ...
        'act_funcs', {{'lin'}}, ...
        'fit_layers', [fit_stim]);
    net_arch = cat(1, net_arch, temp_arch);
    % additive subunit
    temp_arch = struct( ...
        'type', 'add', ...
        'add_targs', [], ...
        'input_targ', 2, ...
        'input_loc', [], ...
        'input_type', 'popavg', ...
        'input_lags', 1, ...
        'input_tent_spacing', 1, ...
        'init', 'gauss', ...
        'reg_params_weights', reg_params.add.weights, ...
        'reg_params_biases', reg_params.add.biases, ...
        'layers', [num_cells], ...
        'act_funcs', {{'lin'}}, ...
        'fit_layers', [1]);
    net_arch = cat(1, net_arch, temp_arch);

    % put it all together
    temp_fit_struct = struct( ...
        'net_io', net_io, ...
        'net_arch', net_arch, ...
        'net_fit', net_fit);

    % append to model_fit_struct
    model_fit_struct = cat(1, model_fit_struct, temp_fit_struct);
    
end

%% add-pup - additive model using pupil diameter
if isfield(model_template, 'add_pup') && model_template.add_pup
            
    % struct for input/output parameters
    net_io.filename_ext = 'add-pup';

    % struct for network architecture
    net_arch = struct([]);
    % stim subunit
    temp_arch = struct( ...
        'type', 'add', ...
        'add_targs', [], ...
        'input_targ', 1, ...
        'input_loc', [], ...
        'input_type', 'stim', ...
        'input_lags', model_struct.stim_struct.num_lags, ...
        'input_tent_spacing', model_struct.stim_struct.tent_spacing, ...
        'init', 'stim', ...
        'reg_params_weights', reg_params.stim.weights, ...
        'reg_params_biases', reg_params.stim.biases, ...
        'layers', [num_cells], ...
        'act_funcs', {{'lin'}}, ...
        'fit_layers', [fit_stim]);
    net_arch = cat(1, net_arch, temp_arch);
    % additive subunit
    temp_arch = struct( ...
        'type', 'add', ...
        'add_targs', [], ...
        'input_targ', 2, ...
        'input_loc', [], ...
        'input_type', 'pup', ...
        'input_lags', 1, ...
        'input_tent_spacing', 1, ...
        'init', 'gauss', ...
        'reg_params_weights', reg_params.add.weights, ...
        'reg_params_biases', reg_params.add.biases, ...
        'layers', [num_cells], ...
        'act_funcs', {{'lin'}}, ...
        'fit_layers', [1]);
    net_arch = cat(1, net_arch, temp_arch);

    % put it all together
    temp_fit_struct = struct( ...
        'net_io', net_io, ...
        'net_arch', net_arch, ...
        'net_fit', net_fit);

    % append to model_fit_struct
    model_fit_struct = cat(1, model_fit_struct, temp_fit_struct);
    
end

%% add-run - additive model using run speed
if isfield(model_template, 'add_run') && model_template.add_run
            
    % struct for input/output parameters
    net_io.filename_ext = 'add-run';
                                      
    % struct for network architecture
    net_arch = struct([]);
    % stim subunit
    temp_arch = struct( ...
        'type', 'add', ...
        'add_targs', [], ...
        'input_targ', 1, ...
        'input_loc', [], ...
        'input_type', 'stim', ...
        'input_lags', model_struct.stim_struct.num_lags, ...
        'input_tent_spacing', model_struct.stim_struct.tent_spacing, ...
        'init', 'stim', ...
        'reg_params_weights', reg_params.stim.weights, ...
        'reg_params_biases', reg_params.stim.biases, ...
        'layers', [num_cells], ...
        'act_funcs', {{'lin'}}, ...
        'fit_layers', [fit_stim]);
    net_arch = cat(1, net_arch, temp_arch);
    % additive subunit
    temp_arch = struct( ...
        'type', 'add', ...
        'add_targs', [], ...
        'input_targ', 2, ...
        'input_loc', [], ...
        'input_type', 'run', ...
        'input_lags', 1, ...
        'input_tent_spacing', 1, ...
        'init', 'gauss', ...
        'reg_params_weights', reg_params.add.weights, ...
        'reg_params_biases', reg_params.add.biases, ...
        'layers', [num_cells], ...
        'act_funcs', {{'lin'}}, ...
        'fit_layers', [1]);
    net_arch = cat(1, net_arch, temp_arch);

    % put it all together
    temp_fit_struct = struct( ...
        'net_io', net_io, ...
        'net_arch', net_arch, ...
        'net_fit', net_fit);

    % append to model_fit_struct
    model_fit_struct = cat(1, model_fit_struct, temp_fit_struct);
    
end

%% add - additive model using population activity (no stimulus)
if isfield(model_template, 'add') && model_template.add
            
    % struct for input/output parameters
    net_io.filename_ext = 'add';
                                     
    % struct for network architecture
    net_arch = struct([]);
    if num_int_bfs.add == 0
        layers = [num_bfs.add, num_cells];
        act_funcs = {{'lin', 'lin'}};
    else
        if model_struct.bfs_symm.add == 1
            layers = ...
                [num_int_bfs.add, num_bfs.add, num_int_bfs.add, num_cells];
            act_funcs = {{'relu', 'relu', 'relu', 'lin'}};
        else
            layers = [num_int_bfs.add, num_bfs.add, num_cells];
            act_funcs = {{'relu', 'relu', 'lin'}};
        end
    end
    % additive subunit
    temp_arch = struct( ...
        'type', 'add', ...
        'add_targs', [], ...
        'input_targ', 1, ...
        'input_loc', [], ...
        'input_type', 'pop', ...
        'input_lags', 1, ...
        'input_tent_spacing', 1, ...
        'init', 'gauss', ...
        'reg_params_weights', reg_params.add.weights, ...
        'reg_params_biases', reg_params.add.biases, ...
        'layers', layers, ...
        'act_funcs', act_funcs, ...
        'fit_layers', ones(length(layers), 1));
    net_arch = cat(1, net_arch, temp_arch);

    % put it all together
    temp_fit_struct = struct( ...
        'net_io', net_io, ...
        'net_arch', net_arch, ...
        'net_fit', net_fit);

    % append to model_fit_struct
    model_fit_struct = cat(1, model_fit_struct, temp_fit_struct);
    
end


%% mult-pop - multiplicative model using population activity
if isfield(model_template, 'mult_pop') && model_template.mult_pop
            
    % struct for input/output parameters
    net_io.filename_ext = 'mult-pop';

    % struct for network architecture
    net_arch = struct([]);
    if num_int_bfs.mult == 0
        layers = [num_bfs.mult, num_cells];
        act_funcs = {{'lin', model_struct.mult_nonlin}};
    else
        layers = [num_int_bfs.mult, num_bfs.mult, num_cells];
        act_funcs = {{'relu', 'lin', model_struct.mult_nonlin}};
    end
    % gain subunit
    temp_arch = struct( ...
        'type', 'add', ...
        'add_targs', [], ...
        'input_targ', 2, ...
        'input_loc', [], ...
        'input_type', 'pop', ...
        'input_lags', 1, ...
        'input_tent_spacing', 1, ...
        'init', 'gauss', ...
        'reg_params_weights', reg_params.mult.weights, ...
        'reg_params_biases', reg_params.mult.biases, ...
        'layers', layers, ...
        'act_funcs', act_funcs, ...
        'fit_layers', ones(length(layers), 1));
    net_arch = cat(1, net_arch, temp_arch);
    % stim subunit
    temp_arch = struct( ...
        'type', 'mult', ...
        'add_targs', 1, ...
        'input_targ', 1, ...
        'input_loc', [], ...
        'input_type', 'stim', ...
        'input_lags', model_struct.stim_struct.num_lags, ...
        'input_tent_spacing', model_struct.stim_struct.tent_spacing, ...
        'init', 'stim', ...
        'reg_params_weights', reg_params.stim.weights, ...
        'reg_params_biases', reg_params.stim.biases, ...
        'layers', [num_cells], ...
        'act_funcs', {{'lin'}}, ...
        'fit_layers', [fit_stim]);
    net_arch = cat(1, net_arch, temp_arch);

    % put it all together
    temp_fit_struct = struct( ...
        'net_io', net_io, ...
        'net_arch', net_arch, ...
        'net_fit', net_fit);

    % append to model_fit_struct
    model_fit_struct = cat(1, model_fit_struct, temp_fit_struct);
    
end

%% mult-popavg - multiplicative model using average population activity
if isfield(model_template, 'mult_popavg') && model_template.mult_popavg
            
    % struct for input/output parameters
    net_io.filename_ext = 'mult-popavg';

    % struct for network architecture
    net_arch = struct([]);
    % gain subunit
    temp_arch = struct( ...
        'type', 'add', ...
        'add_targs', [], ...
        'input_targ', 2, ...
        'input_loc', [], ...
        'input_type', 'popavg', ...
        'input_lags', 1, ...
        'input_tent_spacing', 1, ...
        'init', 'gauss', ...
        'reg_params_weights', reg_params.mult.weights, ...
        'reg_params_biases', reg_params.mult.biases, ...
        'layers', [num_cells], ...
        'act_funcs', {{model_struct.mult_nonlin}}, ...
        'fit_layers', [1]);
    net_arch = cat(1, net_arch, temp_arch);
    % stim subunit
    temp_arch = struct( ...
        'type', 'mult', ...
        'add_targs', 1, ...
        'input_targ', 1, ...
        'input_loc', [], ...
        'input_type', 'stim', ...
        'input_lags', model_struct.stim_struct.num_lags, ...
        'input_tent_spacing', model_struct.stim_struct.tent_spacing, ...
        'init', 'stim', ...
        'reg_params_weights', reg_params.stim.weights, ...
        'reg_params_biases', reg_params.stim.biases, ...
        'layers', [num_cells], ...
        'act_funcs', {{'lin'}}, ...
        'fit_layers', [fit_stim]);
    net_arch = cat(1, net_arch, temp_arch);

    % put it all together
    temp_fit_struct = struct( ...
        'net_io', net_io, ...
        'net_arch', net_arch, ...
        'net_fit', net_fit);

    % append to model_fit_struct
    model_fit_struct = cat(1, model_fit_struct, temp_fit_struct);
    
end

%% mult-pup - multiplicative model using average pupil diameter
if isfield(model_template, 'mult_pup') && model_template.mult_pup
            
    % struct for input/output parameters
    net_io.filename_ext = 'mult-pup';

    % struct for network architecture
    net_arch = struct([]);
    % gain subunit
    temp_arch = struct( ...
        'type', 'add', ...
        'add_targs', [], ...
        'input_targ', 2, ...
        'input_loc', [], ...
        'input_type', 'pup', ...
        'input_lags', 1, ...
        'input_tent_spacing', 1, ...
        'init', 'gauss', ...
        'reg_params_weights', reg_params.mult.weights, ...
        'reg_params_biases', reg_params.mult.biases, ...
        'layers', [num_cells], ...
        'act_funcs', {{model_struct.mult_nonlin}}, ...
        'fit_layers', [1]);
    net_arch = cat(1, net_arch, temp_arch);
    % stim subunit
    temp_arch = struct( ...
        'type', 'mult', ...
        'add_targs', 1, ...
        'input_targ', 1, ...
        'input_loc', [], ...
        'input_type', 'stim', ...
        'input_lags', model_struct.stim_struct.num_lags, ...
        'input_tent_spacing', model_struct.stim_struct.tent_spacing, ...
        'init', 'stim', ...
        'reg_params_weights', reg_params.stim.weights, ...
        'reg_params_biases', reg_params.stim.biases, ...
        'layers', [num_cells], ...
        'act_funcs', {{'lin'}}, ...
        'fit_layers', [fit_stim]);
    net_arch = cat(1, net_arch, temp_arch);

    % put it all together
    temp_fit_struct = struct( ...
        'net_io', net_io, ...
        'net_arch', net_arch, ...
        'net_fit', net_fit);

    % append to model_fit_struct
    model_fit_struct = cat(1, model_fit_struct, temp_fit_struct);
    
end

%% mult-run - multiplicative model using run speed
if isfield(model_template, 'mult_run') && model_template.mult_run
            
    % struct for input/output parameters
    net_io.filename_ext = 'mult-run';

    % struct for network architecture
    net_arch = struct([]);
    % gain subunit
    temp_arch = struct( ...
        'type', 'add', ...
        'add_targs', [], ...
        'input_targ', 2, ...
        'input_loc', [], ...
        'input_type', 'run', ...
        'input_lags', 1, ...
        'input_tent_spacing', 1, ...
        'init', 'gauss', ...
        'reg_params_weights', reg_params.mult.weights, ...
        'reg_params_biases', reg_params.mult.biases, ...
        'layers', [num_cells], ...
        'act_funcs', {{model_struct.mult_nonlin}}, ...
        'fit_layers', [1]);
    net_arch = cat(1, net_arch, temp_arch);
    % stim subunit
    temp_arch = struct( ...
        'type', 'mult', ...
        'add_targs', 1, ...
        'input_targ', 1, ...
        'input_loc', [], ...
        'input_type', 'stim', ...
        'input_lags', model_struct.stim_struct.num_lags, ...
        'input_tent_spacing', model_struct.stim_struct.tent_spacing, ...
        'init', 'stim', ...
        'reg_params_weights', reg_params.stim.weights, ...
        'reg_params_biases', reg_params.stim.biases, ...
        'layers', [num_cells], ...
        'act_funcs', {{'lin'}}, ...
        'fit_layers', [fit_stim]);
    net_arch = cat(1, net_arch, temp_arch);

    % put it all together
    temp_fit_struct = struct( ...
        'net_io', net_io, ...
        'net_arch', net_arch, ...
        'net_fit', net_fit);

    % append to model_fit_struct
    model_fit_struct = cat(1, model_fit_struct, temp_fit_struct);
    
end

%% goris-pop - uniform multiplicative model using population activity
if isfield(model_template, 'goris_pop') && model_template.goris_pop
            
    % struct for input/output parameters
    net_io.filename_ext = 'goris-pop';

    % struct for network architecture
    net_arch = struct([]);
    if num_int_bfs.mult == 0
        layers = [num_bfs.mult, num_cells];
        act_funcs = {{'lin', model_struct.mult_nonlin}};
    else
        layers = [num_int_bfs.mult, num_bfs.mult, num_cells];
        act_funcs = {{'relu', 'lin', model_struct.mult_nonlin}};
    end
    fit_layers = ones(length(layers), 1);
    fit_layers(end) = 0; % don't fit final layer
    % gain subunit
    temp_arch = struct( ...
        'type', 'add', ...
        'add_targs', [], ...
        'input_targ', 2, ...
        'input_loc', [], ...
        'input_type', 'pop', ...
        'input_lags', 1, ...
        'input_tent_spacing', 1, ...
        'init', 'ones', ... % tell fitGamSeries final layer is all 1's
        'reg_params_weights', reg_params.mult.weights, ...
        'reg_params_biases', reg_params.mult.biases, ...
        'layers', layers, ...
        'act_funcs', act_funcs, ...
        'fit_layers', fit_layers);
    net_arch = cat(1, net_arch, temp_arch);
    % stim subunit
    temp_arch = struct( ...
        'type', 'mult', ...
        'add_targs', 1, ...
        'input_targ', 1, ...
        'input_loc', [], ...
        'input_type', 'stim', ...
        'input_lags', model_struct.stim_struct.num_lags, ...
        'input_tent_spacing', model_struct.stim_struct.tent_spacing, ...
        'init', 'stim', ...
        'reg_params_weights', reg_params.stim.weights, ...
        'reg_params_biases', reg_params.stim.biases, ...
        'layers', [num_cells], ...
        'act_funcs', {{'lin'}}, ...
        'fit_layers', [fit_stim]);
    net_arch = cat(1, net_arch, temp_arch);

    % put it all together
    temp_fit_struct = struct( ...
        'net_io', net_io, ...
        'net_arch', net_arch, ...
        'net_fit', net_fit);

    % append to model_fit_struct
    model_fit_struct = cat(1, model_fit_struct, temp_fit_struct);
    
end

%% goris-popavg - uniform multiplicative model using avg pop activity
if isfield(model_template, 'goris_popavg') && model_template.goris_popavg
            
    % struct for input/output parameters
    net_io.filename_ext = 'goris-popavg';

    % struct for network architecture
    net_arch = struct([]);
    layers = [1, num_cells];
    act_funcs = {{'lin', model_struct.mult_nonlin}};
    fit_layers = ones(length(layers), 1);
    fit_layers(end) = 0; % don't fit final layer
    % gain subunit
    temp_arch = struct( ...
        'type', 'add', ...
        'add_targs', [], ...
        'input_targ', 2, ...
        'input_loc', [], ...
        'input_type', 'popavg', ...
        'input_lags', 1, ...
        'input_tent_spacing', 1, ...
        'init', 'ones', ... % tell fitGamSeries final layer is all 1's
        'reg_params_weights', reg_params.mult.weights, ...
        'reg_params_biases', reg_params.mult.biases, ...
        'layers', layers, ...
        'act_funcs', act_funcs, ...
        'fit_layers', fit_layers);
    net_arch = cat(1, net_arch, temp_arch);
    % stim subunit
    temp_arch = struct( ...
        'type', 'mult', ...
        'add_targs', 1, ...
        'input_targ', 1, ...
        'input_loc', [], ...
        'input_type', 'stim', ...
        'input_lags', model_struct.stim_struct.num_lags, ...
        'input_tent_spacing', model_struct.stim_struct.tent_spacing, ...
        'init', 'stim', ...
        'reg_params_weights', reg_params.stim.weights, ...
        'reg_params_biases', reg_params.stim.biases, ...
        'layers', [num_cells], ...
        'act_funcs', {{'lin'}}, ...
        'fit_layers', [fit_stim]);
    net_arch = cat(1, net_arch, temp_arch);

    % put it all together
    temp_fit_struct = struct( ...
        'net_io', net_io, ...
        'net_arch', net_arch, ...
        'net_fit', net_fit);

    % append to model_fit_struct
    model_fit_struct = cat(1, model_fit_struct, temp_fit_struct);
    
end


%% aff-pop - affine model using population activity
if isfield(model_template, 'aff_pop') && model_template.aff_pop
            
    % struct for input/output parameters
    net_io.filename_ext = 'aff-pop';
    
    % struct for network architecture
    net_arch = struct([]);
    if num_int_bfs.add == 0
        layers_add = [num_bfs.add, num_cells];
        act_funcs_add = {{'lin', 'lin'}};
    else
        if model_struct.bfs_symm.add == 1
            layers_add = ...
                [num_int_bfs.add, num_bfs.add, num_int_bfs.add, num_cells];
            act_funcs_add = {{'relu', 'relu', 'relu', 'lin'}};
        else
            layers_add = [num_int_bfs.add, num_bfs.add, num_cells];
            act_funcs_add = {{'relu', 'relu', 'lin'}};
        end
    end
    if num_int_bfs.mult == 0
        layers_mult = [num_bfs.mult, num_cells];
        act_funcs_mult = {{'lin', model_struct.mult_nonlin}};
    else
        layers_mult = [num_int_bfs.mult, num_bfs.mult, num_cells];
        act_funcs_mult = {{'relu', 'lin', model_struct.mult_nonlin}};
    end
    % gain subunit
    temp_arch = struct( ...
        'type', 'add', ...
        'add_targs', [], ...
        'input_targ', 2, ...
        'input_loc', [], ...
        'input_type', 'pop', ...
        'input_lags', 1, ...
        'input_tent_spacing', 1, ...
        'init', 'gauss', ...
        'reg_params_weights', reg_params.mult.weights, ...
        'reg_params_biases', reg_params.mult.biases, ...
        'layers', layers_mult, ...
        'act_funcs', act_funcs_mult, ...
        'fit_layers', ones(length(layers_mult), 1));
    net_arch = cat(1, net_arch, temp_arch);
    % stim subunit
    temp_arch = struct( ...
        'type', 'mult', ...
        'add_targs', 1, ...
        'input_targ', 1, ...
        'input_loc', [], ...
        'input_type', 'stim', ...
        'input_lags', model_struct.stim_struct.num_lags, ...
        'input_tent_spacing', model_struct.stim_struct.tent_spacing, ...
        'init', 'stim', ...
        'reg_params_weights', reg_params.stim.weights, ...
        'reg_params_biases', reg_params.stim.biases, ...
        'layers', [num_cells], ...
        'act_funcs', {{'lin'}}, ...
        'fit_layers', [fit_stim]);
    net_arch = cat(1, net_arch, temp_arch);
    % add subunit
    temp_arch = struct( ...
        'type', 'add', ...
        'add_targs', [], ...
        'input_targ', 2, ...
        'input_loc', [], ...
        'input_type', 'pop', ...
        'input_lags', 1, ...
        'input_tent_spacing', 1, ...
        'init', 'gauss', ...
        'reg_params_weights', reg_params.add.weights, ...
        'reg_params_biases', reg_params.add.biases, ...
        'layers', layers_add, ...
        'act_funcs', act_funcs_add, ...
        'fit_layers', ones(length(layers_add), 1));
    net_arch = cat(1, net_arch, temp_arch);

    % put it all together
    temp_fit_struct = struct( ...
        'net_io', net_io, ...
        'net_arch', net_arch, ...
        'net_fit', net_fit);

    % append to model_fit_struct
    model_fit_struct = cat(1, model_fit_struct, temp_fit_struct);
    
end

%% aff-popavg - affine model using average population activity
if isfield(model_template, 'aff_popavg') && model_template.aff_popavg
            
    % struct for input/output parameters
    net_io.filename_ext = 'aff-popavg';

    % struct for network architecture
    net_arch = struct([]);
    % gain subunit
    temp_arch = struct( ...
        'type', 'add', ...
        'add_targs', [], ...
        'input_targ', 2, ...
        'input_loc', [], ...
        'input_type', 'popavg', ...
        'input_lags', 1, ...
        'input_tent_spacing', 1, ...
        'init', 'gauss', ...
        'reg_params_weights', reg_params.mult.weights, ...
        'reg_params_biases', reg_params.mult.biases, ...
        'layers', [num_cells], ...
        'act_funcs', {{model_struct.mult_nonlin}}, ...
        'fit_layers', [1]);
    net_arch = cat(1, net_arch, temp_arch);
    % stim subunit
    temp_arch = struct( ...
        'type', 'mult', ...
        'add_targs', 1, ...
        'input_targ', 1, ...
        'input_loc', [], ...
        'input_type', 'stim', ...
        'input_lags', model_struct.stim_struct.num_lags, ...
        'input_tent_spacing', model_struct.stim_struct.tent_spacing, ...
        'init', 'stim', ...
        'reg_params_weights', reg_params.stim.weights, ...
        'reg_params_biases', reg_params.stim.biases, ...
        'layers', [num_cells], ...
        'act_funcs', {{'lin'}}, ...
        'fit_layers', [fit_stim]);
    net_arch = cat(1, net_arch, temp_arch);
    % add subunit
    temp_arch = struct( ...
        'type', 'add', ...
        'add_targs', [], ...
        'input_targ', 2, ...
        'input_loc', [], ...
        'input_type', 'popavg', ...
        'input_lags', 1, ...
        'input_tent_spacing', 1, ...
        'init', 'gauss', ...
        'reg_params_weights', reg_params.add.weights, ...
        'reg_params_biases', reg_params.add.biases, ...
        'layers', [num_cells], ...
        'act_funcs', {{'lin'}}, ...
        'fit_layers', [1]);
    net_arch = cat(1, net_arch, temp_arch);

    % put it all together
    temp_fit_struct = struct( ...
        'net_io', net_io, ...
        'net_arch', net_arch, ...
        'net_fit', net_fit);

    % append to model_fit_struct
    model_fit_struct = cat(1, model_fit_struct, temp_fit_struct);
    
end

%% aff-pup - affine model using pupil diameter
if isfield(model_template, 'aff_pup') && model_template.aff_pup
            
    % struct for input/output parameters
    net_io.filename_ext = 'aff-pup';

    % struct for network architecture
    net_arch = struct([]);
    % gain subunit
    temp_arch = struct( ...
        'type', 'add', ...
        'add_targs', [], ...
        'input_targ', 2, ...
        'input_loc', [], ...
        'input_type', 'pup', ...
        'input_lags', 1, ...
        'input_tent_spacing', 1, ...
        'init', 'gauss', ...
        'reg_params_weights', reg_params.mult.weights, ...
        'reg_params_biases', reg_params.mult.biases, ...
        'layers', [num_cells], ...
        'act_funcs', {{model_struct.mult_nonlin}}, ...
        'fit_layers', [1]);
    net_arch = cat(1, net_arch, temp_arch);
    % stim subunit
    temp_arch = struct( ...
        'type', 'mult', ...
        'add_targs', 1, ...
        'input_targ', 1, ...
        'input_loc', [], ...
        'input_type', 'stim', ...
        'input_lags', model_struct.stim_struct.num_lags, ...
        'input_tent_spacing', model_struct.stim_struct.tent_spacing, ...
        'init', 'stim', ...
        'reg_params_weights', reg_params.stim.weights, ...
        'reg_params_biases', reg_params.stim.biases, ...
        'layers', [num_cells], ...
        'act_funcs', {{'lin'}}, ...
        'fit_layers', [fit_stim]);
    net_arch = cat(1, net_arch, temp_arch);
    % add subunit
    temp_arch = struct( ...
        'type', 'add', ...
        'add_targs', [], ...
        'input_targ', 2, ...
        'input_loc', [], ...
        'input_type', 'pup', ...
        'input_lags', 1, ...
        'input_tent_spacing', 1, ...
        'init', 'gauss', ...
        'reg_params_weights', reg_params.add.weights, ...
        'reg_params_biases', reg_params.add.biases, ...
        'layers', [num_cells], ...
        'act_funcs', {{'lin'}}, ...
        'fit_layers', [1]);
    net_arch = cat(1, net_arch, temp_arch);

    % put it all together
    temp_fit_struct = struct( ...
        'net_io', net_io, ...
        'net_arch', net_arch, ...
        'net_fit', net_fit);

    % append to model_fit_struct
    model_fit_struct = cat(1, model_fit_struct, temp_fit_struct);
    
end

%% aff-run - affine model using run speed
if isfield(model_template, 'aff_run') && model_template.aff_run
            
    % struct for input/output parameters
    net_io.filename_ext = 'aff-run';

    % struct for network architecture
    net_arch = struct([]);
    % gain subunit
    temp_arch = struct( ...
        'type', 'add', ...
        'add_targs', [], ...
        'input_targ', 2, ...
        'input_loc', [], ...
        'input_type', 'run', ...
        'input_lags', 1, ...
        'input_tent_spacing', 1, ...
        'init', 'gauss', ...
        'reg_params_weights', reg_params.mult.weights, ...
        'reg_params_biases', reg_params.mult.biases, ...
        'layers', [num_cells], ...
        'act_funcs', {{model_struct.mult_nonlin}}, ...
        'fit_layers', [1]);
    net_arch = cat(1, net_arch, temp_arch);
    % stim subunit
    temp_arch = struct( ...
        'type', 'mult', ...
        'add_targs', 1, ...
        'input_targ', 1, ...
        'input_loc', [], ...
        'input_type', 'stim', ...
        'input_lags', model_struct.stim_struct.num_lags, ...
        'input_tent_spacing', model_struct.stim_struct.tent_spacing, ...
        'init', 'stim', ...
        'reg_params_weights', reg_params.stim.weights, ...
        'reg_params_biases', reg_params.stim.biases, ...
        'layers', [num_cells], ...
        'act_funcs', {{'lin'}}, ...
        'fit_layers', [fit_stim]);
    net_arch = cat(1, net_arch, temp_arch);
    % add subunit
    temp_arch = struct( ...
        'type', 'add', ...
        'add_targs', [], ...
        'input_targ', 2, ...
        'input_loc', [], ...
        'input_type', 'run', ...
        'input_lags', 1, ...
        'input_tent_spacing', 1, ...
        'init', 'gauss', ...
        'reg_params_weights', reg_params.add.weights, ...
        'reg_params_biases', reg_params.add.biases, ...
        'layers', [num_cells], ...
        'act_funcs', {{'lin'}}, ...
        'fit_layers', [1]);
    net_arch = cat(1, net_arch, temp_arch);

    % put it all together
    temp_fit_struct = struct( ...
        'net_io', net_io, ...
        'net_arch', net_arch, ...
        'net_fit', net_fit);

    % append to model_fit_struct
    model_fit_struct = cat(1, model_fit_struct, temp_fit_struct);
    
end

%% lin-pop - lin model using population activity
if isfield(model_template, 'lin_pop') && model_template.lin_pop
            
    % struct for input/output parameters
    net_io.filename_ext = 'lin-pop';
    
    % struct for network architecture
    net_arch = struct([]);
    if num_int_bfs.add == 0
        layers_add = [num_bfs.add, num_cells];
        act_funcs_add = {{'lin', 'lin'}};
    else
        if model_struct.bfs_symm.add == 1
            layers_add = ...
                [num_int_bfs.add, num_bfs.add, num_int_bfs.add, num_cells];
            act_funcs_add = {{'relu', 'relu', 'relu', 'lin'}};
        else
            layers_add = [num_int_bfs.add, num_bfs.add, num_cells];
            act_funcs_add = {{'relu', 'relu', 'lin'}};
        end
    end
    if num_int_bfs.mult == 0
        layers_mult = [num_bfs.mult, num_cells];
        act_funcs_mult = {{'lin', model_struct.mult_nonlin}};
    else
        layers_mult = [num_int_bfs.mult, num_bfs.mult, num_cells];
        act_funcs_mult = {{'relu', 'lin', model_struct.mult_nonlin}};
    end
    fit_layers_mult = ones(length(layers_mult), 1);
    fit_layers_mult(end) = 0; % don't fit final layer
    % gain subunit
    temp_arch = struct( ...
        'type', 'add', ...
        'add_targs', [], ...
        'input_targ', 2, ...
        'input_loc', [], ...
        'input_type', 'pop', ...
        'input_lags', 1, ...
        'input_tent_spacing', 1, ...
        'init', 'ones', ... % tell fitGamSeries final layer is all 1's
        'reg_params_weights', reg_params.mult.weights, ...
        'reg_params_biases', reg_params.mult.biases, ...
        'layers', layers_mult, ...
        'act_funcs', act_funcs_mult, ...
        'fit_layers', fit_layers_mult);
    net_arch = cat(1, net_arch, temp_arch);
    % stim subunit
    temp_arch = struct( ...
        'type', 'mult', ...
        'add_targs', 1, ...
        'input_targ', 1, ...
        'input_loc', [], ...
        'input_type', 'stim', ...
        'input_lags', model_struct.stim_struct.num_lags, ...
        'input_tent_spacing', model_struct.stim_struct.tent_spacing, ...
        'init', 'stim', ...
        'reg_params_weights', reg_params.stim.weights, ...
        'reg_params_biases', reg_params.stim.biases, ...
        'layers', [num_cells], ...
        'act_funcs', {{'lin'}}, ...
        'fit_layers', [fit_stim]);
    net_arch = cat(1, net_arch, temp_arch);
    % add subunit
    temp_arch = struct( ...
        'type', 'add', ...
        'add_targs', [], ...
        'input_targ', 2, ...
        'input_loc', [], ...
        'input_type', 'pop', ...
        'input_lags', 1, ...
        'input_tent_spacing', 1, ...
        'init', 'gauss', ...
        'reg_params_weights', reg_params.add.weights, ...
        'reg_params_biases', reg_params.add.biases, ...
        'layers', layers_add, ...
        'act_funcs', act_funcs_add, ...
        'fit_layers', ones(length(layers_add), 1));
    net_arch = cat(1, net_arch, temp_arch);

    % put it all together
    temp_fit_struct = struct( ...
        'net_io', net_io, ...
        'net_arch', net_arch, ...
        'net_fit', net_fit);

    % append to model_fit_struct
    model_fit_struct = cat(1, model_fit_struct, temp_fit_struct);
    
end

%% lin-popavg - affine model using average population activity
if isfield(model_template, 'lin_popavg') && model_template.lin_popavg
            
    % struct for input/output parameters
    net_io.filename_ext = 'lin-popavg';

    % struct for network architecture
    net_arch = struct([]);
    layers_mult = [1, num_cells];
    act_funcs_mult = {{'lin', model_struct.mult_nonlin}};
    fit_layers_mult = ones(length(layers_mult), 1);
    fit_layers_mult(end) = 0; % don't fit final layer
    % gain subunit
    temp_arch = struct( ...
        'type', 'add', ...
        'add_targs', [], ...
        'input_targ', 2, ...
        'input_loc', [], ...
        'input_type', 'popavg', ...
        'input_lags', 1, ...
        'input_tent_spacing', 1, ...
        'init', 'ones', ... % tell fitGamSeries final layer is all 1's
        'reg_params_weights', reg_params.mult.weights, ...
        'reg_params_biases', reg_params.mult.biases, ...
        'layers', layers_mult, ...
        'act_funcs', act_funcs_mult, ...
        'fit_layers', fit_layers_mult);
    net_arch = cat(1, net_arch, temp_arch);
    % stim subunit
    temp_arch = struct( ...
        'type', 'mult', ...
        'add_targs', 1, ...
        'input_targ', 1, ...
        'input_loc', [], ...
        'input_type', 'stim', ...
        'input_lags', model_struct.stim_struct.num_lags, ...
        'input_tent_spacing', model_struct.stim_struct.tent_spacing, ...
        'init', 'stim', ...
        'reg_params_weights', reg_params.stim.weights, ...
        'reg_params_biases', reg_params.stim.biases, ...
        'layers', [num_cells], ...
        'act_funcs', {{'lin'}}, ...
        'fit_layers', [fit_stim]);
    net_arch = cat(1, net_arch, temp_arch);
    % add subunit
    temp_arch = struct( ...
        'type', 'add', ...
        'add_targs', [], ...
        'input_targ', 2, ...
        'input_loc', [], ...
        'input_type', 'popavg', ...
        'input_lags', 1, ...
        'input_tent_spacing', 1, ...
        'init', 'gauss', ...
        'reg_params_weights', reg_params.add.weights, ...
        'reg_params_biases', reg_params.add.biases, ...
        'layers', [num_cells], ...
        'act_funcs', {{'lin'}}, ...
        'fit_layers', [1]);
    net_arch = cat(1, net_arch, temp_arch);

    % put it all together
    temp_fit_struct = struct( ...
        'net_io', net_io, ...
        'net_arch', net_arch, ...
        'net_fit', net_fit);

    % append to model_fit_struct
    model_fit_struct = cat(1, model_fit_struct, temp_fit_struct);
    
end





    
    